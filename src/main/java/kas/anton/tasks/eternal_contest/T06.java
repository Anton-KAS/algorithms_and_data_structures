package kas.anton.tasks.eternal_contest;

import java.util.Scanner;

/**
 * @author Anton Komrachkov
 * @since (13.12.2022)
 */

/*
На физкультуре происходит разбиение по двум командам.
Ребята выстроены в шеренгу, у каждого из них есть свой рост a_i
Разбиение по командам произойдет по принципу «четный-нечетный»
— все школьники с четным ростом отправляются в одну команду, а нечетные — в другую.

В отличие от привычного урока, ребята не выстроились по росту.
Вместо привычного порядка они встали случайно. Теперь физрук Яша смотрит на шеренгу и думает
— может ли ровно одна пара учеников поменяться местами так,
чтобы команды оказались такими же, как и по принципу «первый-второй».
Иначе говоря, он хочет получить такой порядок,
при котором все ученики с четным ростом стоят на четных позициях, а с нечетным — на нечетных.
Помогите Яше найти нужную замену.

Формат входных данных
В первой строке находится число n (2 ≤ n ≤ 1000) — количество учеников в шеренге.
В следующей строке находится n натуральных чисел a_i (1 ≤ a_i ≤ 10^9) — рост учеников.

Формат выходных данных
В единственной строке выведите i и j — номера элементов, которые нужно поменять местами,
чтобы добиться заданного условия (1 ≤ i, j ≤ n,i != j).
Если ответов несколько — разрешается вывести любой.
Если не существует способа поменять два элемента местами — выведите -1 −1.

Замечания
В первом примере хотя бы один ученик с четным ростом будет стоять на нечетной позиции.
Во втором тесте замена приведет к неправильному состоянию.
В третьем тесте из условия замена приведет шеренгу к валидному состоянию [1,2].

Примеры данных
Пример 1
Ввод:
4
2 1 4 6
Вывод: -1 -1

Пример 2
Ввод:
2
1 2
Вывод: -1 -1

Пример 3
Ввод:
2
2 1
Вывод: 1 2
 */

public class T06 {
    public static void main(String[] args) {
        int n; // (2 ≤ n ≤ 1000) — количество учеников в шеренге
        int[] ai; // (1 ≤ a_i ≤ 10^9) — рост учеников
        try (Scanner scanner = new Scanner(System.in)) {
            n = scanner.nextInt();
            ai = new int[n];
            for (int i = 0; i < n; i++) ai[i] = scanner.nextInt();
        }

        int setI = -1;
        int setJ = -1;
        int countNotEven = 0;
        int countNotOdd = 0;
        for (int h = 0; h < ai.length; h += 1) {
            if (((h + 1) % 2) != 0) {
                if ((ai[h] % 2) != 0) continue;
                setI = h + 1;
                countNotOdd++;
            } else {
                if ((ai[h] % 2) == 0) continue;
                setJ = h + 1;
                countNotEven++;
            }
            if (countNotEven > 1 || countNotOdd > 1) {
                break;
            }
        }

        if (countNotEven == 1 && countNotOdd == 1 && setI != setJ) {
            // Приводим к i > j - вроде необязательно, но пусть будет (так удобнее для автотестов)
            if (setI > setJ) {
                int temp = setI;
                setI = setJ;
                setJ = temp;
            }
        } else if (countNotEven == 0 && countNotOdd == 0 && ai.length >= 3) {
            // По сути все на своих местах, меняем любые два нечетных (или два четных) местами
            setI = 1;
            setJ = 3;
        } else {
            setI = -1;
            setJ = -1;
        }

        System.out.printf("%s %s\n", setI, setJ);
    }
}
